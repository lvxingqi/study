version01
    使用私有构造器和静态方法获取实例，延迟创建对象，（懒汉式）
    但是当多个线程第一次同时访问时，可能会创建多个对象
version02
    加入关键词synchronized，这样每次线程只能进入一个，保证不会产生多个对象，
    但是只有第一次才需要同步，后面使用的都是同一个实例，会严重影响性能（频繁使用的实例）
version03
    直接初始化静态对象，每次返回该对象即可，适用于（占用资源不是很严重的实例），这样保证
    了线程安全。
version04
    双重检查加锁，当实例为null时才同步。（最优选择，不用考虑占用资源情况）
    volatile关键字保证指令不会重排，没有volatile关键字的时候，
    线程A进入检查，instance==null，开始创建实例，但是由于指令重排，分为分配内存，
    调用构造函数，将实例指向内存等步骤，此时线程B进入，检查instance！=null成立，
    直接返回，然而此时可能instance还没有完整实例化，返回null，出现问题。
    第一个判断instance==null，确保只有instance为空时才进入同步块，
    第二个判断的作用时为了解决线程安全的问题，如果没有第二个判断，
    线程A检查instance==null成立，进入同步块，此时，线程B检查instance==null，也进入
    同步块，线程B先实例化对象，线程A后实例化对象，两个线程实例化了两个对象，这样就违背了
    单例模式的初衷，所以需要第二个判断，确保一旦出现实例对象，即使有别的线程进入了同步块，也不会
    继续实例化一个对象。
    总之，第一个判断是决定进不进入同步块，第二个判断保证了线程安全，volatile关键字
    保证了不会因为指令重排而返回null。

    注意：使用类加载器加载单件是，如果不是同一个类加载器，可能会产生多个实例，不同的类加载器
    加载同一个类的时候，认为这是不同的类，所以使用类加载器的时候要注意，防止被初始化不止一次，
    这样单例模式就会失效